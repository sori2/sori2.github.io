---
title: P vs NP
sidebar:
  nav: docs-en
aside:
  toc: true
key: 2024062901_en
tags: Algorithm
lang: en
---

# Introduction to P vs NP

**P vs NP** 문제는 컴퓨터 과학에서 가장 유명하고 중요한 난제 중 하나로, 클레이 수학연구소가 선정한 밀레니엄 문제 중 하나로 널리 알려져 있다. 이 문제는 1971년 Stephen Cook의 주요 논문 "The Complexity of Theorem-Proving Procedures"에서 처음 제기되었으며, 수십 년간 수많은 연구자들에게 도전 과제를 제공해 왔다. 이 문제가 해결될 경우 컴퓨터 과학과 수학의 많은 분야에 깊은 영향을 미칠 것으로 예상된다.

여기서 P와 NP는 각각 특정 조건을 만족하는 결정 문제의 집합을 의미한다. P vs NP 문제의 논의는 다음과 같다. P 집합과 NP 집합이 같은지 다른지를 증명하기만 하면 된다. 자세히 말해,

- 같다.
- 다르다.
- 증명할 수 없다.

중 어느 한쪽으로만 증명하면 된다.

이 글에서는 P vs NP 문제에 대해서 간략히 소개를 해보고자 한다. 그 전에 앞서, P와 NP에 이해에 중요한 역할을 하는 Efficient Algorithm의 개념을 소개하고자 한다.

# Efficient Algorithm

효율적인 알고리즘이란 무엇일까? 이를 정확하게 설명하면, 다항 시간 내에 문제를 해결할 수 있는 알고리즘을 효율적이라고 말한다. 즉, 알고리즘의 실행 시간이 입력 길이의 다항 함수일 때 이를 효율적이라고 정의한다.정확히 이해가 안 될 수도 있다.

현대 컴퓨터 과학에서는 효율적인 알고리즘이 매우 중요하게 여겨진다. 이는 단순히 자원 절약의 이유만은 아니다. 여러 가지 이유로 효율적인 알고리즘의 중요성을 설명할 수 있다.

먼저, 하드웨어 발전 속도의 둔화이다. 과거에는 하드웨어의 성능 향상이 매우 빠르게 이루어졌기 때문에 소프트웨어의 비효율성을 어느 정도 상쇄할 수 있었다. 그러나 최근 몇 년간 하드웨어 발전 속도는 점점 느려지고 있으며, 이는 소프트웨어 최적화의 중요성을 더욱 부각시키고 있다. 효율적인 알고리즘을 사용하면 하드웨어의 제약을 극복하고 성능을 극대화할 수 있다.

그리고, 빅데이터 시대가 도래함에 따라 우리는 엄청난 양의 데이터를 처리하고 분석해야 하는 상황에 직면해 있다. 조금만 비효율적인 알고리즘을 사용해도 처리 시간이 기하급수적으로 증가하는 것을 볼 수 있다.

즉, 효율적인 알고리즘의 중요성은 단순히 이론적인 문제가 아니라, 실질적인 문제 해결과 성능 최적화를 위한 필수 요소로 자리잡고 있다.

이제, 효율적인 알고리즘이 무엇을 뜻하는지 정확히 설명해 보겠다. 앞서 말한 것처럼, 효율적인 알고리즘은 다항 시간 내에 문제를 해결할 수 있는 알고리즘이다. 이러한 정의를 위해서는 알고리즘의 복잡도에 대한 개념이 필수적이다. 복잡도는 크게 시간 복잡도와 공간 복잡도로 나눌 수 있다. 시간 복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 나타내고, 공간 복잡도는 알고리즘이 사용하는 메모리 양을 나타낸다. 효율적인 알고리즘은 일반적으로 시간 복잡도가 다항 시간인 알고리즘을 의미한다. 이는 알고리즘의 실행 시간이 입력 길이에 대해 다항 함수로 표현될 수 있다는 것을 의미한다.

복잡도 이론에 대해 더 자세히 알고 싶으면관 이 글을 참고하면 된다.

위의 글을 읽고 왔으면, "알고리즘의 실행 시간이 다항 시간으로 나타나는 알고리즘을 효율적이라고 말함"의 의미를 명확히 이해할 수 있다. 지수 시간만 되어도 적당히 큰 입력 크기만 되어도 현실적으로 해결하기 어렵다는 것을 알 수 있다. 예시를 들어보자면, 대표적으로 비밀번호 맞추기 알고리즘이 있다. 비밀번호를 맞추는 방법은 제한된 길이 내의 모든 알파벳과 특수문자를 하나씩 바꾸어가며 시도하는 방법밖에 없다. 이는 매우 많은 시간이 든다는 것을 쉽게 알 수 있다. (또한 대부분의 사이트는 비밀번호 입력 횟수 제한을 두기 때문에 이는 거의 불가능에 가깝다.)

최악의 시간 복잡도인 지수 시간의 알고리즘 대신, 다항 시간의 알고리즘을 찾기 위해 많은 컴퓨터 과학자들이 노력하고 있다. 이에 관한 놀라운 성과 중 하나로 **AKS 소수 판별법**을 말할 수 있다. 이는 최초로 발견된 일반적이고, 무조건적이고, 결정론적인 다항 시간 소수 판별 알고리즘이다.



# Deterministic vs Non-Deterministic Algorithm

알고리즘을 크게  두 가지로 구분할 수 있다.

- 결정론적 알고리즘
- 비결정론적 알고리즘

## Deterministic Algorithm

결정론적 알고리즘은 일련의 명확한 규칙을 따르는 알고리즘이다. 우리가 흔히 생각하는 알고리즘의 개념과 매우비슷하다. 즉, 특정한 입력이 주어지면 항상 동일한 과정을 거쳐 동일한 출력을 생성한다. 결정론적이라는 의미는 그 다음 단계가 이미 결정되어있다는 의미로 해석하면 된다.

- **버블 정렬**: 주어진 리스트를 정렬할 때, 명확하게 정의된 규칙을 따라 어떤 입력에 대해서도 항상 동일한 순서로 정렬된 출력을 만든다. 예를 들어, 리스트 $[4, 2, 3, 1]$이 주어지면, 버블 정렬은 항상 같은 방식으로 비교하고 교환하여 정렬된 리스트 $[1, 2, 3, 4]$를 생성한다.

## Non-Deterministic Algorithm

비결정론적 알고리즘은 문제를 푸는 각 단계에서 여러 가지 가능성을 병렬적으로 고려할 수 있는 알고리즘을 말한다. 즉, 결정론적 알고리즘과 달리, 각 단계에서 다음 단계가 유일하게 결정되지 않는다. 이는 모든 가능한 경로를 동시에 탐색하는 것처럼 작동한다. 이해가 잘 안될 수 있는데, 실제 컴퓨터는 비결정론적 계산을 수행할 수 없기 때문이다. 그래서, 이론적으로 모든 가능성을 동시에 고려할 수 있다고 가정하자.

- **두 갈래길 탐색** : 길의 끝에 보물이 있다고 가정하자. 하지만 경로를 탐색하던 도중, 두 갈래길을 발견했다. 결정론적 알고리즘에서는 경로 탐색 도중 두 갈래길이 나올 때, 특정 규칙(예: 항상 왼쪽을 먼저 탐색하는 규칙)에 따라 한쪽 경로를 선택한다. 예를 들어, 왼쪽 길을 먼저 탐색한다. 만약 더 이상 진행할 수 없거나 보물을 발견하지 못했다면, 다시 돌아와 오른쪽 길을 탐색해야 한다. 즉, 각 경로를 순차적으로 탐색하는 방식이다.하지만, 같은 상황에서, 비결정론적 알고리즘은 두 갈래길이 나올 때, 왼쪽과 오른쪽 경로를 동시에 탐색할 수 있다고 가정할 수 있다. 마치 한 세포가 두 개의 세포로 분열하듯이, 비결정론적 알고리즘은 분기점에서 분열되어 각 경로를 동시에 탐색한다. 이론적으로는 모든 가능한 경로를 병렬적으로 고려하여 탐색하므로, 어느 경로에 보물이 있든지 더 빠르게 발견할 수 있다

사실 비결정론적인 알고리즘은 실제로 구현할 수 없기 때문에, 이 개념을 정의하는 이유에 의문이 들 수 있다. 그러나 비결정론적 알고리즘을 정의하는 것은 컴퓨터 과학의 다양한 문제를 분석하고 해결하는 데 중요한 역할을 한다. 이는 이론적으로 모든 가능성을 동시에 고려할 수 있다는 가정 아래, 복잡한 문제를 더 깊이 이해하고 접근할 수 있는 틀을 제공하기 때문이다. 특히, P vs NP 문제와 같은 난제를 탐구하는 데 있어 매우 중요한 개념 중 하나다.

# P vs NP

어떤 **결정론적 알고리즘**으로 **다항 시간에 해결할 수 있는** 결정 문제들의 집합을 $\text{P}$라고 한다. 즉, $\text{P}$는 결정 문제들 중에서 효율적으로 해결 가능한 문제들을 모아놓은 집합이다.

다항 시간 내에 문제의 답을 Yes 혹은 No로 계산해낼 수 있는 알고리즘이 존재한다면, 그 문제는 $\text{P}$에 속한다고 말한다. 이를 수학적으로 표현하면 다음과 같다.

$$
\text{P}=\bigcup_{k=1}^{\infty}\text{TIME}[n^k]
$$

모든 $k$에 대해 $n^k$에 비례하는 시간 복잡도를 가진 문제의 합집합이 $\text{P}$를 구성한다는 것을 의미한다. (다시 말해, 다항 시간 내에 해결 가능한 모든 결정 문제들의 집합이 $\text{P}$인 것이다.